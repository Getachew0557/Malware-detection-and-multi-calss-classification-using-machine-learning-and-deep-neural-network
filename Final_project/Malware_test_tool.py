#Inporting Required Librarires
import os
from threading import Thread
import pefile
import array
import math
import pickle
import joblib
import sys
from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QApplication, QDialog
from PyQt5.uic import loadUi
import win10toast

#8888888888888888888888888888888888888888888888888
from joblib import Parallel, delayed
from time import sleep,time

r = Parallel( n_jobs = -2, verbose = 10, batch_size='auto')
(delayed(sleep)(.2) for _ in range(10)) #doctest: +SKIP
start_t = time()

#Entropy Function - To detect the repetitive patterns that are near to each other in the sequence which would indicate a deviation from the assumption of randomness
def get_entropy(data):
    if len(data) == 0:
        return 0.0
    occurences = array.array('L', [0]*256)
    for x in data:
        occurences[x if isinstance(x, int) else ord(x)] += 1

    entropy = 0
    for x in occurences:
        if x:
            p_x = float(x) / len(data)
            entropy -= p_x*math.log(p_x, 2)

    return entropy

#Function to Extract Resources
def get_resources(pe):
    resources = []
    if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        try:
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'directory'):
                            for resource_lang in resource_id.directory.entries:
                                data = pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
                                size = resource_lang.data.struct.Size
                                entropy = get_entropy(data)

                                resources.append([entropy, size])
        except Exception as e:
            return resources
    return resources


#Function to Get Info of each Resource
def get_version_info(pe):
    res = {}
    for fileinfo in pe.FileInfo:
        if fileinfo.Key == 'StringFileInfo':
            for st in fileinfo.StringTable:
                for entry in st.entries.items():
                    res[entry[0]] = entry[1]
        if fileinfo.Key == 'VarFileInfo':
            for var in fileinfo.Var:
                res[var.entry.items()[0][0]] = var.entry.items()[0][1]
    if hasattr(pe, 'VS_FIXEDFILEINFO'):
          res['flags'] = pe.VS_FIXEDFILEINFO.FileFlags
          res['os'] = pe.VS_FIXEDFILEINFO.FileOS
          res['type'] = pe.VS_FIXEDFILEINFO.FileType
          res['file_version'] = pe.VS_FIXEDFILEINFO.FileVersionLS
          res['product_version'] = pe.VS_FIXEDFILEINFO.ProductVersionLS
          res['signature'] = pe.VS_FIXEDFILEINFO.Signature
          res['struct_version'] = pe.VS_FIXEDFILEINFO.StrucVersion
    return res

#Function to Extract Infos
def extract_infos(fpath):
    res = {}
    pe = pefile.PE(fpath)
    res['Machine'] = pe.FILE_HEADER.Machine
    res['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
    res['Characteristics'] = pe.FILE_HEADER.Characteristics
    res['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
    res['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
    res['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
    res['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
    res['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
    res['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    res['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
    try:
        res['BaseOfData'] = pe.OPTIONAL_HEADER.BaseOfData
    except AttributeError:
        res['BaseOfData'] = 0
    res['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
    res['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
    res['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
    res['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
    res['MinorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
    res['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
    res['MinorImageVersion'] = pe.OPTIONAL_HEADER.MinorImageVersion
    res['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
    res['MinorSubsystemVersion'] = pe.OPTIONAL_HEADER.MinorSubsystemVersion
    res['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
    res['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
    res['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
    res['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
    res['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics
    res['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
    res['SizeOfStackCommit'] = pe.OPTIONAL_HEADER.SizeOfStackCommit
    res['SizeOfHeapReserve'] = pe.OPTIONAL_HEADER.SizeOfHeapReserve
    res['SizeOfHeapCommit'] = pe.OPTIONAL_HEADER.SizeOfHeapCommit
    res['LoaderFlags'] = pe.OPTIONAL_HEADER.LoaderFlags
    res['NumberOfRvaAndSizes'] = pe.OPTIONAL_HEADER.NumberOfRvaAndSizes

    # Sections
    res['SectionsNb'] = len(pe.sections)
    entropy = map(lambda x:x.get_entropy(), pe.sections)
    s=len(list(entropy))
    res['SectionsMeanEntropy'] = sum(entropy)/float(s)
    res['SectionsMinEntropy'] = min(entropy,default=0)
    res['SectionsMaxEntropy'] = max(entropy,default=0)
    raw_sizes = map(lambda x:x.SizeOfRawData, pe.sections)
    t=len(list(raw_sizes))
    res['SectionsMeanRawsize'] = sum(raw_sizes)/float(t)
    res['SectionsMinRawsize'] = min(raw_sizes,default=0)
    res['SectionsMaxRawsize'] = max(raw_sizes,default=0)
    virtual_sizes = map(lambda x:x.Misc_VirtualSize, pe.sections)
    
    u=len(list(virtual_sizes))
    res['SectionsMeanVirtualsize'] = sum(virtual_sizes)/float(u)
    res['SectionsMinVirtualsize'] = min(virtual_sizes,default=0)
    res['SectionMaxVirtualsize'] = max(virtual_sizes,default=0)

    #Imports
    try:
        res['ImportsNbDLL'] = len(pe.DIRECTORY_ENTRY_IMPORT)
        imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
        res['ImportsNb'] = len(imports)
        
        v=list(filter(lambda x:x.name is None, imports))
        res['ImportsNbOrdinal'] = len(v)
    except AttributeError:
        res['ImportsNbDLL'] = 0
        res['ImportsNb'] = 0
        res['ImportsNbOrdinal'] = 0

    #Exports
    try:
        res['ExportNb'] = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)
    except AttributeError:
        # No export
        res['ExportNb'] = 0
    #Resources
    resources= get_resources(pe)
    res['ResourcesNb'] = len(resources)
    if len(resources)> 0:
        entropy = map(lambda x:x[0], resources)
        
        w=len(list(entropy))
        res['ResourcesMeanEntropy'] = sum(entropy)/float(w)
        res['ResourcesMinEntropy'] = min(entropy,default=0)
        res['ResourcesMaxEntropy'] = max(entropy,default=0)
        sizes = map(lambda x:x[1], resources)
        
        p=len(list(sizes))
        res['ResourcesMeanSize'] = sum(sizes)/float(p)
        res['ResourcesMinSize'] = min(sizes,default=0)
        res['ResourcesMaxSize'] = max(sizes,default=0)
    else:
        res['ResourcesNb'] = 0
        res['ResourcesMeanEntropy'] = 0
        res['ResourcesMinEntropy'] = 0
        res['ResourcesMaxEntropy'] = 0
        res['ResourcesMeanSize'] = 0
        res['ResourcesMinSize'] = 0
        res['ResourcesMaxSize'] = 0

    # Load configuration size
    try:
        res['LoadConfigurationSize'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size
    except AttributeError:
        res['LoadConfigurationSize'] = 0


    # Version configuration size
    try:
        version_infos = get_version_info(pe)
        res['VersionInformationSize'] = len(version_infos.keys())
    except AttributeError:
        res['VersionInformationSize'] = 0
    return res

# class for user interface

class Parrallel_input():
    def parallel(self):
        print("this is")
obje = Parrallel_input()
t1 = Thread(target=obje.parallel)
t1.start()

class my_window(QDialog):
    def __init__(self):
        super(my_window,self).__init__()
        width = 700
        height = 400
        self.setGeometry(550, 200, 700, 400)
        self.setWindowTitle("ሀሁ መሞከሪያ መሳሪያ")
        self.setStyleSheet('background-color: #262D37;')

        #define function in main class
        self.initUI()
        #self.result_display()
        

    #function for button and labels

    def initUI(self):
        self.lbl_Title = QtWidgets.QLabel(self)
        self.lbl_Title.setText("Well Come to Malware Detection tool ")
        self.lbl_Title.move(70,50)
        self.lbl_Title.setStyleSheet('color:pink;'
                                       'font-size:28px;' 
                                       'font-weight:bold ')

                
        # self.txt_surname = QtWidgets.QLineEdit(self)
        # self.txt_surname.move(200,90)
        # self.txt_surname.resize(200,32)

        # button for file browse
        obje = Parrallel_input()
        btn = QtWidgets.QPushButton('Browse Files', self)
        btn.resize(250, 75)
        btn.clicked.connect(self.FileBrowse)
        btn.move(150, 170) 
        btn.setStyleSheet('background:pink;'
                          'font-size:20px;' 
                          'border:2px solid purple;'  
                          'font-weight:bold; '
                          'border-radius:75px;'
                          )

        # button for save file
        # self.btn_save = QtWidgets.QPushButton(self)
        # self.btn_save.setText("Save")
        # self.btn_save.clicked.connect(self.clicked)
        # self.btn_save.move(200,350)
        # self.btn_save.setStyleSheet('background-color:blue;' 
        #                             'color: white;' 
        #                             'font-size = 20px;'
        #                             )

    # method for display result 
    def clicked(self):
        self.lbl_result.setText('Name\t :')
        print("hello")

    # def result_display(self):
    #     self.lbl_result = QtWidgets.QLabel(self)
    #     self.lbl_result.setText("results")
    #     self.lbl_result.move(200,300)
    #     #self.lbl_result.resize(200,200)



    # method for file browse
    def A():
        FileBrowse()
    t1 = Thread(target = A)
    t1.start()
    
    
    
    def FileBrowse(self):
        
   
    #def FileBrowse(self):
        # self.lbl_result = QtWidgets.QLabel(self)
        # self.lbl_result.setText("results")
        # self.lbl_result.move(200,300)
    

        filepath ,flag = QtWidgets.QFileDialog.getOpenFileNames(self, 
                                                       'Multiple File',
                                                       "C:\\Users\\Getcho\\Downloads\Programs",
                                                       "*.exe"
                                                       )
        # for loop for itereting each pe file 
   
        for file_path in filepath:
           
            if file_path!='':
                clf = joblib.load("classifier.pkl")
                features=pickle.loads(open("features.pkl",'rb').read())
            
                try:   
                    data = extract_infos(file_path)
                    pe_features = list(map(lambda x:data[x], features))
                    res= clf.predict([pe_features])[0]
                    print('...............................................')
                    ans=('%s - %s' %(os.path.basename(file_path),['SAFE SOFTWARE', 'MALICIOUS SOFTWARE'][res])) 
                    print(ans)
                    print('................................................')

                    toaster=win10toast.ToastNotifier()
                    if(res==1):
                        toaster.show_toast('Malware Detector Tool',ans,duration=10,icon_path="C:/Users/Getcho/Pictures/Malware_detection/Delete.ico")
                    else:
                        toaster.show_toast('Malware Detector Tool',ans,duration=10,icon_path="C:/Users/Getcho/Pictures/Malware_detection/Delete.ico")
                except:
                    toas_error=win10toast.ToastNotifier()
                    toas_error.show_toast('Malware Detector','Invalid FILE FORMAT',duration=10,icon_path="Oxygen-Icons.org-Oxygen-Actions-window-close.ico")

        print("file path: ", filepath)
    

def MainWindow():
        app = QApplication(sys.argv)
        win = my_window()
        win.show() #displays the widget on the monitor screen.
        sys.exit(app.exec_())

        
MainWindow()

# if __name__ == '__main__':
#         app = QApplication(sys.argv)
#         win = my_window()
#         win.show() #displays the widget on the monitor screen.
#         sys.exit(app.exec_())